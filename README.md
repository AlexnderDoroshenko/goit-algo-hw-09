# goit-algo-hw-09
Home work 9 Algorithms greedy and dynamic.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Результати тестування:

Тест: Сума 113:
  Жадібний алгоритм: {50: 2, 10: 1, 2: 1, 1: 1} (Час: 0.000776 секунд)
  Динамічне програмування: {1: 1, 2: 1, 10: 1, 50: 2} (Час: 0.063248 секунд)

Тест: Сума 75 (можна зібрати найбільшими номіналами):
  Жадібний алгоритм: {50: 1, 25: 1} (Час: 0.000959 секунд)
  Динамічне програмування: {25: 1, 50: 1} (Час: 0.040021 секунд)

Тест: Сума 8 (складний випадок):
  Жадібний алгоритм: {5: 1, 2: 1, 1: 1} (Час: 0.001026 секунд)
  Динамічне програмування: {1: 1, 2: 1, 5: 1} (Час: 0.004655 секунд)

Тест: Сума 1000:
  Жадібний алгоритм: {50: 20} (Час: 0.000550 секунд)
  Динамічне програмування: {50: 20} (Час: 0.701853 секунд)

Тест: Сума 234:
  Жадібний алгоритм: {50: 4, 25: 1, 5: 1, 2: 2} (Час: 0.000722 секунд)
  Динамічне програмування: {2: 2, 5: 1, 25: 1, 50: 4} (Час: 0.135560 секунд)

Тест: Сума 99 (складний випадок):
  Жадібний алгоритм: {50: 1, 25: 1, 10: 2, 2: 2} (Час: 0.000725 секунд)
  Динамічне програмування: {2: 2, 10: 2, 25: 1, 50: 1} (Час: 0.052799 секунд)

Тест: Сума 33 (складний випадок):
  Жадібний алгоритм: {25: 1, 5: 1, 2: 1, 1: 1} (Час: 0.001289 секунд)
  Динамічне програмування: {1: 1, 2: 1, 5: 1, 25: 1} (Час: 0.015867 секунд)

Тест: Сума 0 (0 копійок):
  Жадібний алгоритм: {} (Час: 0.000236 секунд)
  Динамічне програмування: {} (Час: 0.002002 секунд)


Жадібний алгоритм повернув: {25: 1, 1: 5}
Traceback (most recent call last):
  File "c:\Users\adore\Neoversity\python\Algorithms\goit-algo-hw-09\cash_back_helper.py", line 140, in <module>
    test_greedy_failure()
  File "c:\Users\adore\Neoversity\python\Algorithms\goit-algo-hw-09\cash_back_helper.py", line 128, in test_greedy_failure
    assert greedy_result == expected_min_coins, \
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: Жадібний алгоритм надав не оптимальне рішення! очикується {10: 3}, фактичний результат {25: 1, 1: 5}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Висновок:

При великих сумах, алгоритм динамічного програмування, хоч і повільніший, завжди забезпечує точність у видачі здачі. Це робить його більш надійним вибором у випадках, коли потрібно отримати точний результат.
Жадібний алгоритм, хоча й ефективний за часом, може призвести до не оптимальних розрахунків.